---
title: "Selecting optimal color palettes"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, message = FALSE)
```

```{r packages, cache = FALSE, message = FALSE}
library(tidyverse)
library(sf)
library(tidycensus)
library(RColorBrewer)
library(gridExtra)

if(!identical(getOption("bitmapType"), "cairo") && isTRUE(capabilities()[["cairo"]])){
  options(bitmapType = "cairo")
}

options(digits = 3)
set.seed(1234)
theme_set(theme_minimal())
```

# Select a color palette

Selection of your **color palette** is perhaps the most important decision to make when drawing a choropleth. By default, `ggplot2` picks evenly spaced hues around the [Hue-Chroma-Luminance (HCL) color space](https://en.wikipedia.org/wiki/HCL_color_space):^[Check out chapter 6.6.2 in *`ggplot2`: Elegant Graphics for Data Analysis* for a much more thorough explanation of the theory behind this selection process]

```{r color-wheel}
# generate simulated data points
sim_points <- data_frame(x = factor(1:6))

plots <- purrr::map(1:6, ~ ggplot(sim_points[1:.x, ], aes(x, x, color = x)) +
  geom_point(size = 5) +
    ggtitle(paste(.x, "color")) +
  theme(legend.position = "none"))

gridExtra::marrangeGrob(plots, nrow = 2, ncol = 3, top = NULL)
```

`ggplot2` gives you many different ways of defining and customizing your `scale_color_` and `scale_fill_` palettes, but will not tell you if they are optimal for your specific usage in the graph.

# Color Brewer

```{r get-maps, include = FALSE}
# get national median household income
usa_inc <- get_acs(geography = "us", 
                   variables = c(medincome = "B19013_001"), 
                   year = 2016) %>%
  .$estimate %>%
  nth(1)

# get state-level median household income and region
state_inc <- get_acs(geography = "state", 
                     variables = c(medincome = "B19013_001"), 
                     year = 2016,
                     geometry = TRUE) %>%
  # remove alaska, hawaii, and puerto rico
  filter(!(NAME %in% c("Alaska", "Hawaii", "Puerto Rico"))) %>%
  # calculate diff from national income
  mutate(estimate_div = estimate - usa_inc)

# get state-level region
state_region <- get_decennial(geography = "state", 
                              variables = c(region = "REGION"), 
                              year = 2010,
                              geometry = TRUE) %>%
  # remove alaska, hawaii, and puerto rico
  filter(!(NAME %in% c("Alaska", "Hawaii", "Puerto Rico"))) %>%
  mutate(value = factor(value, labels = c("Northeast", "Midwest", "South", "West")))
```

[Color Brewer](http://colorbrewer2.org/) is a diagnostic tool for selecting optimal color palettes for maps with discrete variables. The authors have generated different color palettes designed to make differentiating between categories easy depending on the scaling of your variable. All you need to do is define the number of categories in the variable, the nature of your data (sequential, diverging, or qualitative), and a color scheme. There are also options to select palettes that are colorblind safe, print friendly, and photocopy safe. Depending on the combination of options, you may not find any color palette that matches your criteria. In such a case, consider reducing the number of data classes.

#### Sequential

Sequential palettes work best with ordered data that progresses from a low to high value.

```{r cb-seq}
display.brewer.all(type = "seq")
```

```{r cb-seq-map, echo = FALSE}
cut_interval_format <- function (x, n = NULL, length = NULL, ...) {
  kimisc::cut_format(x, ggplot2:::breaks(x, "width", n, length), include.lowest = TRUE, 
      ...)
}

seq_plot <- state_inc %>%
  mutate(estimate_cut = cut_interval_format(estimate, 6, dig.lab = 5,
                                            format_fun = scales::dollar)) %>%
  ggplot() +
  geom_sf(aes(fill = estimate_cut)) +
  labs(title = "Median household income, 2016",
       caption = "Source: 2016 American Community Survey",
       fill = NULL)

seq_plot +
  scale_fill_brewer(palette = "Blues") +
  labs(subtitle = "Palette: Blues")

seq_plot +
  scale_fill_brewer(palette = "BuGn") +
  labs(subtitle = "Palette: BuGn")

seq_plot +
  scale_fill_brewer(palette = "YlGn") +
  labs(subtitle = "Palette: YlGn")
```

#### Diverging

```{r cb-div}
display.brewer.all(type = "div")
```

#### Qualitative

```{r cb-qual}
display.brewer.all(type = "qual")
```

# Viridis

> Also check out the [`viridis`](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) package for generating optimal continuous color scales.


# Session Info {.toc-ignore}

```{r child='_sessioninfo.Rmd'}
```
