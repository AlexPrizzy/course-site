---
title: "Row-oriented workflows"
date: 2019-03-01

type: docs
toc: true
draft: false
categories: ["project-management"]

menu:
  notes:
    parent: Project management
    weight: 6
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(cache = TRUE)
```

```{r packages, cache = FALSE, message = FALSE}
library(tidyverse)
library(gapminder)
library(rcfss)

set.seed(1234)
theme_set(theme_minimal())
```

The data frame is an important data structure in R. In fact, virtually all of the analysis we've done up until this point utilizes a data frame. Given the [tidy data format](/notes/tidy-data/) with variables stored in columns, most of our operations are performed column-wise. But what about row-oriented work? Operations in R can be performed row-wise, but are sometimes more awkward to implement. Here we examine multiple methods for implementing row-wise operations using the `tidyverse`.

## Don't create odd little excerpts and copies of your data

Code style that results from (I speculate) minimizing the number of key presses.

```{r gapminder-df}
# prep gapminder for the examples to come
gapminder <- gapminder %>%
  arrange(continent) %>%
  as.data.frame()
```

```{r split-data}
life_exp <- gapminder[1:624, 4]
gdp_per_cap <- gapminder[1:624, 6]
plot(gdp_per_cap ~ life_exp)
```

This clutters the workspace with "loose parts", `life_exp` and `gdp_per_cap`. Very soon, you are likely to forget what they are, which countries of `gapminder` they represent, and what the relationship between them is.

## Leave the data *in situ* and reveal intent in your code

More verbose code conveys intent. Eliminating the Magic Numbers makes the code less likely to be, or become, wrong.

Here's one way to do same in a `tidyverse` style:

```{r plot-no-split}
ggplot(
  data = filter(gapminder, continent == "Africa"),
  mapping = aes(x = lifeExp, y = gdpPercap)
) +
  geom_point()
```

Another `tidyverse` approach, this time using the pipe operator, `%>%`

```{r plot-no-split-pipe}
gapminder %>%
  filter(continent == "Africa") %>%
  ggplot(mapping = aes(x = lifeExp, y = gdpPercap)) +
  geom_point()
```

A base solution that still follows the principles of

* Leave the data in data frame
* Convey intent

```{r plot-no-split-base}
plot(
  gdpPercap ~ lifeExp,
  data = subset(gapminder, subset = continent == "Africa")
)
```

## Add or modify a variable

```{r new-df}
# Function to produce a fresh example data frame
new_people <- function() {
  tribble(
    ~name, ~age,
    "Reed", 14L,
    "Wesley", 12L,
    "Eli", 12L,
    "Toby", 1L
  )
}
```

## The `df$var <- ...` syntax

How to create or modify a variable is a fairly low stakes matter, i.e. really a matter of taste. That said, I think there are arguments in favor of a tidy approach to modifying or creating columns inside of data frames.

Of course, `df$var <- ...` absolutely works for creating new variables or modifying existing ones. But there are downsides:

* Silent recycling is a risk.
* `df` is not special. It's not the implied place to look first for things,
so you must be explicit. This can be a drag.
* I have aesthetic concerns. YMMV.

```{r df-new-var-base}
people <- new_people()
people$eyes <- 2L
people$snack <- c("chips", "cheese")
people$uname <- toupper(people$name)
people
```

## `dplyr::mutate()` works "inside the box"

`dplyr::mutate()` is the `tidyverse` way to work on a variable. If I'm working in a script-y style and the `tidyverse` packages are already available, I generally prefer this method of adding or modifying a variable.

* Only a length one input can be recycled.
* `people` is the first place to look for things. It turns out that making a
new variable out of existing variables is very, very common, so it's nice
when this is easy.
* This is pipe-friendly, so I can easily combine with a few other logical
data manipuluations that need to happen around the same point.
* I like the way this looks. YMMV.

```{r df-new-var-mutate-recycle, error = TRUE}
new_people() %>%
  mutate(
    eyes = 2L,
    snack = c("chips", "cheese"),
    uname = toupper(name)
  )
```

Oops! I did not provide enough snacks!

```{r df-new-var-mutate}
new_people() %>%
  mutate(
    eyes = 2L,
    snack = c("chips", "cheese", "mixed nuts", "dried peas"),
    uname = str_to_upper(name)
  )
```

## Are you absolutely sure that you, personally, need to iterate over rows?

Sometimes it's easy to fixate on one (unfavorable) way of accomplishing something, because it feels like a natural extension of a successful small-scale experiment.

Let's create a string from row 1 of the data frame.

```{r df-new-string}
people <- new_people()
paste(people$name[1], "is", people$age[1], "years old")
```

I want to scale up, therefore I obviously must ... loop over all rows!

```{r df-new-string-loop}
n_people <- nrow(people)
s <- vector(mode = "character", length = n_people)
for (i in seq_len(n_people)) {
  s[i] <- paste(people$name[i], "is", people$age[i], "years old")
}
s
```

Or even better, write a `map()` function!

```{r df-new-string-map}
map2_chr(people$name, people$age, ~ paste(.x, "is", .y, "years old"))
```

HOLD ON. What if I told you `paste()` is already vectorized over its arguments?

```{r df-new-string-vectorized}
paste(people$name, "is", people$age, "years old")
```

A surprising number of "iterate over rows" problems can be eliminated by exploiting functions that are already vectorized and by making your own functions vectorized over the primary argument.

Writing an explicit loop in your code is not necessarily bad, but it should always give you pause. Has someone already written this loop for you? Ideally in C or C++ and inside a package that's being regularly checked, with high test coverage. That is usually the better choice.

## Don't forget to work "inside the box"

For this string interpolation task, we can even work with a vectorized function that is happy to do lookup inside a data frame. The [`glue` package](https://glue.tidyverse.org) is doing the work under the hood here, but many of its functions are now re-exported by `stringr`, which we already attached via `library(tidyverse)`.

```{r df-new-string-glue}
str_glue_data(people, "{name} is {age} years old")
```

You can use the simpler form, `str_glue()`, inside `dplyr::mutate()`, because
the other variables in `df` are automatically available for use.

```{r df-new-string-glue-mutate}
people %>%
  mutate(sentence = str_glue("{name} is {age} years old"))
```

The `tidyverse` style is to manage data holistically in a data frame and provide a user interface that encourages self-explaining code with low "syntactical noise".

## `purrr::map()` for functions that are not vectorized

```{r df-list}
df_list <- list(
  mass_shootings,
  gun_deaths
)
df_list
```

This does not work. `nrow()` expects a single data frame as input.

```{r df-list-nrow, error = TRUE, dependson = "df-list"}
nrow(df_list)
```

`purrr::map()` applies `nrow()` to each element of `df_list`.

```{r df-list-nrow-map, dependson = "df-list"}
library(purrr)
map(df_list, nrow)
```

Different calling styles make sense in more complicated situations. Hard to justify in this simple example.

```{r df-list-nrow-map-more-complex, dependson = "df-list"}
map(df_list, ~ nrow(.x))

df_list %>%
  map(nrow)
```

If you know what the return type is (or *should* be), use a type-specific variant of `map()`.

```{r df-list-nrow-map-int, dependson = "df-list"}
map_int(df_list, ~ nrow(.x))
```

## Attack via rows or columns?

If you must sweat, compare row-wise work vs. column-wise work

The approach you use in that first example is not always the one that scales up the best.

```{r gen-list}
veggies <- list(
  list(name = "sue", number = 1, veg = c("onion", "carrot")),
  list(name = "doug", number = 2, veg = c("potato", "beet"))
)
veggies
```

If we want to combine these into rows in a data frame, how can we do this?

```{r bind-rows-fail, error = TRUE, dependson = "gen-list"}
bind_rows(veggies)
map_dfr(veggies, ~.x)
map_dfr(veggies, ~ .x[c("name", "number")])
```

Sometimes it is simpler to attack the problem column-wise, rather than row-wise.

```{r bind-rows-sep-map, dependson = "gen-list"}
tibble(
  name = map_chr(veggies, "name"),
  number = map_dbl(veggies, "number"),
  veg = map(veggies, "veg")
)
```

## Work on groups of rows via `dplyr::group_by()` + `summarize()`

What if you need to work on groups of rows? Such as the groups induced by the levels of a factor.

You do not need to split the data frame into mini-data-frames, loop over them, and glue it all back together.

Instead, use `dplyr::group_by()`, followed by `dplyr::summarize()`, to compute group-wise summaries.

```{r group-by-sum}
gapminder %>%
  group_by(continent) %>%
  summarize(
    life_exp_avg = mean(lifeExp),
    gdp_per_cap_avg = mean(gdpPercap)
  )
```

What if you want to return summaries that are not just a single number? This does not "just work":

```{r sum-multiple, error = TRUE}
gapminder %>%
  group_by(continent) %>%
  summarize(life_exp_qtile = quantile(lifeExp, c(0.25, 0.5, 0.75)))
```

Solution: package as a length-1 `list()` that contains 3 values, creating a **list-column**.

```{r sum-multiple-list}
gapminder %>%
  group_by(continent) %>%
  summarize(life_exp_qtile = list(quantile(lifeExp, c(0.25, 0.5, 0.75))))
```

{{< tweet 983997363298717696 >}}

Solution: you can `map()` `tibble::enframe()` on the new list column, to convert each entry from named list to a two-column data frame. Then use `tidyr::unnest()` to get rid of the list column and return to a simple data frame and, if you like, convert `quantile` into a factor.

```{r sum-multiple-list-unnest}
gapminder %>%
  group_by(continent) %>%
  summarize(life_exp_qtile = list(quantile(lifeExp, c(0.25, 0.5, 0.75)))) %>%
  mutate(life_exp_qtile = map(life_exp_qtile, enframe, name = "quantile")) %>%
  unnest(life_exp_qtile) %>%
  mutate(quantile = factor(quantile))
```

If something like this comes up a lot in an analysis, you could package the key "moves" in a function, like so:

```{r quantile-function}
enquantile <- function(.var, ...) {
  qtile <- enframe(quantile(.var, ...), name = "quantile")
  qtile$quantile <- factor(qtile$quantile)
  list(qtile)
}
```

This makes repeated downstream usage more concise.

```{r sum-multiple-list-quantile-function, dependson = "quantile-function"}
gapminder %>%
  group_by(continent) %>%
  summarize(life_exp_qtile = enquantile(lifeExp, c(0.25, 0.5, 0.75))) %>%
  unnest(life_exp_qtile)
```

## Acknowledgments

* Substantial material drawn from [Row-oriented workflows in R with the tidyverse
](https://github.com/jennybc/row-oriented-workflows) by Jenny Bryan. Licensed under the licensed under the [CC BY-SA 4.0 Creative Commons License](https://creativecommons.org/licenses/by-sa/4.0/).

## Session Info

```{r child = here::here("R", "_session-info.Rmd")}

```
